@precedence {
  name,
  call,
  filter @left,
  qnamePath @left,
  path @left,
  instanceOf,
  prefix,
  exp @left,
  times @left,
  add @left,
  compare @left,
  and @left,
  or @left,
  unaryTest @cut,
  then @left,
  else @left
}

expression {
  textualExpression |
  boxedExpression
}

textualExpressions {
  commaSep<textualExpression>
}

textualExpression {
  ForExpression {
    kw<"for"> InExpressions<IterationContext> kw<"return"> expression
  } |
  IfExpression {
    kw<"if"> expression !then kw<"then"> expression (!else kw<"else"> expression)?
  } |
  QuantifiedExpression {
    (kw<"some"> | kw<"every">) InExpressions<expression> kw<"satisfies"> expression
  } |
  Disjunction {
    expression !or kw<"or"> expression
  } |
  Conjunction {
    expression !and kw<"and"> expression
  } |
  Comparison |
  ArithmeticExpression |
  InstanceOf {
    expression !instanceOf instanceOf Type
  } |
  PathExpression {
    expression !path "." Name
  } |
  FilterExpression {
    expression !filter "[" expression "]"
  } |
  FunctionInvocation |
  literal |
  QualifiedName ~qname /* TODO(nikku): should be name according to spec */ |
  kw<"?"> |
  SimplePositiveUnaryTest |
  ParenthesizedExpression { "(" expression ")" }
}

boxedExpression {
  List |
  FunctionDefinition |
  Context
}

InExpressions<Expr> {
  commaSep1<InExpression<Expr>>
}

InExpression<Expr> {
  Name kw<"in"> Expr
}

IterationContext {
  expression (".." expression)?
}

ArithmeticExpression {
  expression !add (ArithOp<"+"> | minus) expression |
  expression !times (ArithOp<"*"> | divide) expression |
  expression !exp ArithOp<"^" | "**"> expression |
  !prefix (ArithOp<"+"> | minus) expression
}

Comparison {
  expression !compare CompareOp<"=" | "!="> expression |
  expression !compare CompareOp<Gt | Gte | Lt | Lte> expression |
  expression !compare kw<"between"> expression kw<"and"> expression |
  expression !compare kw<"in"> PositiveUnaryTest |
  expression !compare kw<"in"> !unaryTest "(" PositiveUnaryTests ")"
}

SimplePositiveUnaryTest {
  CompareOp<Gt | Gte | Lt | Lte> endpoint |
  Interval
}

@top[name=UnaryTests] {
  Wildcard |
  PositiveUnaryTests |
  not "(" PositiveUnaryTests ")"
}

PositiveUnaryTests {
  commaSep1<PositiveUnaryTest>
}

PositiveUnaryTest {
  expression
}

FunctionDefinition {
  kw<"function"> "(" commaSep<FormalParameter> ")" kw<"external">? expression
}

FormalParameter {
  ParameterName (":" Type)?
}

Type {
  QualifiedName
}

Context {
  "{" commaSep<ContextEntry> "}"
}

ContextEntry {
  Key ":" expression
}

Key {
  Name |
  StringLiteral
}

FunctionInvocation {
  (BuiltInFunctionName | expression)  !call Parameters
}

Parameters {
  "(" (NamedParameters | PositionalParameters)? ")"
}

NamedParameters {
  commaSep1<ParameterName ":" expression>
}

ParameterName {
  Name
}

PositionalParameters {
  commaSep1<expression>
}

endpoint {
  QualifiedName ~qname |
  simpleLiteral ~literal
}

literal {
  kw<"null"> |
  simpleLiteral ~literal
}

simpleLiteral {
  NumericLiteral |
  StringLiteral |
  BooleanLiteral
}

QualifiedName {
  Name (!qnamePath "." Name)*
}

Interval {
  ( "]" | "(" | "[" ) ~interval endpoint ".." endpoint ( ")" | "[" | "]" )
}

List {
  "[" ~interval commaSep<expression> "]"
}

kw<Term> {
  @specialize[name={Term}]<Name, Term>
}

/*
ckw<Term> {
  @extend[name={Term}]<Name, Term>
}
*/

commaSep1<Expr> {
  Expr ("," Expr)*
}

commaSep<Expr> {
  "" | Expr ("," Expr)*
}

@skip { whitespace | LineComment | BlockComment }

@tokens {

  LineComment[skipped=true] { "//" ![\n]* }

  BlockComment[skipped=true] { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  VerticalSpace {
    $[\u000A-\u000D]
  }

  whitespace {
    VerticalSpace | std.whitespace+
  }

  Digit {
    $[0-9]
  }

  Digits {
    Digit+
  }

  divide[name=ArithOp] { "/" }

  minus[name=ArithOp] { "-" }

  /* 35. string literal = """, { character â€“ (""" | vertical space) | string escape sequence}, """ ; */
  StringLiteral {
    '"' (![\\\n"] | "\\" _)* '"'?
  }

  Wildcard { "-" }

  NumericLiteral {
    "-"? (Digits ("." Digits)? | "." Digits)
  }

  BooleanLiteral {
    "true" | "false"
  }

  instanceOf {
    "instance of"
  }

  not[name="not"] { "not" }

  BuiltInFunctionName {
    "date" |
    "date and time" |
    "time" |
    "number" |
    "string" |
    "duration" |
    "years and months duration" |
    not |
    "substring" |
    "string length" |
    "upper case" |
    "lower case" |
    "substring before" |
    "substring after" |
    "replace" |
    "contains" |
    "starts with" |
    "ends with" |
    "split" |
    "list contains" |
    "count" |
    "min" |
    "max" |
    "sum" |
    "mean" |
    "all" |
    "any" |
    "sublist" |
    "append" |
    "concatenate" |
    "insert before" |
    "remove" |
    "reverse" |
    "index of" |
    "union" |
    "distinct values" |
    "flatten" |
    "product" |
    "median" |
    "stddev" |
    "mode" |
    "decimal" |
    "floor" |
    "ceiling" |
    "abs" |
    "modulo" |
    "sqrt" |
    "log" |
    "exp" |
    "odd" |
    "even" |
    "is" |
    "before" |
    "after" |
    "meets" |
    "met by" |
    "overlaps" |
    "overlaps before" |
    "overlaps after" |
    "finishes" |
    "finished by" |
    "includes" |
    "during" |
    "starts" |
    "started by" |
    "coincides" |
    "day of year" |
    "day of week" |
    "month of year" |
    "week of year" |
    "sort" |
    "get value" |
    "get entries"
  }

  Gt { ">" }
  Lt { "<" }
  Gte { ">=" }
  Lte { "<=" }

  @precedence { BlockComment, LineComment, divide }

  @precedence {
    not,
    BuiltInFunctionName,
    BooleanLiteral,
    NumericLiteral,
    instanceOf,
    Name
  }

  @precedence {
    NumericLiteral,
    Wildcard,
    minus
  }

  @precedence {
    NumericLiteral,
    "."
  }

  NameStart {
    nameStartChar namePartChar*
  }

  nameStartChar {
    "?" | $[A-Z] | "_" | $[a-z] |
    $[\u{200C}-\u{200D}] | $[$\u{2070}-\u{218F}] | $[\u{2C00}-\u{2FEF}] | $[\u{3001}-\u{D7FF}] | $[\u{F900}-\u{FDCF}] | $[\u{FDF0}-\u{FFFD}] | $[\u{10000}-\u{EFFFF}]
  }

  namePartChar {
    nameStartChar | Digit | $[\u0300-\u036F] | $[\u203F-\u2040]
  }

  NamePart {
    namePartChar+
  }

  Name {
    NameStart (NamePart)*
  }

  "(" ")" "[" "]" "{" "}"

  ArithOp<Expr> {
    Expr
  }

  CompareOp<Expr> {
    Expr
  }

}